联机脱机

# 0.问题

OS定义：操作系统是位于硬件层(HAL)之上、所有其它软件层之下的一个**系统软件**，是管理系统中各种软硬件资源（CPU、内存、文件、外设）、方便用户使用计算机系统（命令方式、API、GUI）的程序集合

四大特性：
并发（最重要的）： 与并行的区别？
共享：（概念）   互斥/同步
虚拟：（概念）
异步：进程在执行中，其执行时间、顺序、向前推进的速度和完成的时间等都是不可预知的 产生原因：资源限制等原因

并发和共享是两个基本特征，互为存在条件
只有并发才要求共享，只有合理共享才能正确并发

硬件环境

定时装置：

系统栈：**内存**中操作系统空间的一个固定区域

用途：1.保存中断现场 2.保存子程序的参数变量

注意：1.每个运行程序都有一个对应的系统栈 2.进程切换的同时伴随系统栈的切换3.硬件只有一个系统栈指针作用。

<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240228091502306.png" alt="image-20240228091502306" style="zoom: 50%;" />

特权指令和非特权指令

```
特权指令
○ 从指令系统（指令集）角度定义，在指令系统中拥有用于管理硬件和整个系统安全的指令，让程序随意使用具有极高危险性。不得在用户态（目态）执行，只能在核心态（管态）执行，用户态程序如果运行特权指令将发生异常，并切换到管态由操作系统接管cpu。所以用户程序不得使用特权指令，需要执行特权指令需要使用防管指令，进入核心态。

访管指令
○ 同样从指令集的角度定义，或者说从硬件角度（cpu状态）。防管指令，是用户程序自愿进管的指令（进管同时也意味着程序放弃cpu的控制权），该指令本身属于非特权指令，可在用户态执行，执行后进入核心态。核心态是通过cpu置相应标志表明当前处于核心态。cpu进入核心态后可以执行指令集中的所有指令（包括特权指令和非特权指令，但不执行访管指令）。
```

处理机状态

管态也称系统态、核心态，操作系统运行时所处的状态。机器处于管态时可以执行硬件提供的**全部指令**，包括特权指令和非特权指令。 由于利用**特权指令可以修改PSW**，而机器状态位是PSW的一部分，因而在管态下可以通过修改PSW来改变机器状态，使之由管态转换为目态

目态也称用户态，**是一般用户程序运行时所处的状态。**处理机处于**目态**时只能执行非特权指令。

管态到目态：修改机器状态字 目态到管态：中断



每个访管指令后面都是一个系统调用，每一个系统调用后面都是一个中断



为什么目态到管态的唯一途径是中断？？？？？**产生中断意味着当前程序不能继续执行，处理机需分配执行中断服务例程，而分配CPU则是管态才能执行的**

中断装置

发现中断：识别中断

响应中断：先将当前进程的中断向量(PSW和PC)压入**系统栈**，再根据中断源到指定内存单元将新的中断向量取来并送到**中断向量寄存器**中, 从而转到对应的中断处理程序。

中断驱动

 操作系统如何取代P1获得CPU的使用权/ 现在操作系统机理？现代OS是中断驱动，并发运行，每个程序都是运行暂停，所以中断是程序切换的必要条件。处理机状态分配在管态下才能进行，执行目态到管态的唯一途径是中断。



# 进程

## 导图：

进程的引入：单道的缺点（3）、多道的优点（3）、多道面临的问题

进程：一个指标：吞吐量

9条：<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240313084627349.png" alt="image-20240313084627349" style="zoom:50%;" />







-----------------------------------------------------------

进程是程序关于一个数据集合的一次运行活动（包括数据集和操作集）

进程状态：运行态、就绪态、等待态 （刚被创建的进程属于就绪态）

<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240313090250061.png" alt="image-20240313090250061" style="zoom:60%;" />

时间片满改为抢占式调度

<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240313090307868.png" alt="image-20240313090307868" style="zoom:77%;" />

进程由三部分构成，PCB，操作集，数据集。PCB在系统空间，操作集和数据集在用户空间

进程控制块是进程存在的唯一标志

**进程上下文**：进程运行的物理环境，记录寄存器、堆、栈等内容 

进程的切换就是上下文的切换

**进程队列**：就绪队列、执行队列、阻塞队列

**进程的类型和特性**：用户进程（目态）和系统进程（管态）

**进程间相互联系与相互作用：**
相互联系：相关进程（在逻辑上具有某种联系的进程称作相关进程）和无关进程
一般地，属于同一进程家族内的所有进程都是相关的。
无关进程间虽没有逻辑关系，但有资源竞争关系，如互斥、死锁、饿死等（无关进程还是有关系）

相互作用：直接作用（有意识）和间接作用（无意识）
直接相互作用只发生在**相关进程之间**。 间接相互作用可能发生在**任意进程之间**。

**进程和程序的联系和区别**

用户级线程：在目态实现，TCB处于用户空间， 比如，运行系统
用户级线程对操作系统不可见，每个进程对应一个系统栈
核心级线程：在管态实现， TCB处于系统空间，
线程的创建、撤销、状态转换由操作系统完成，每个线程对应一个系统栈

TCB可以在系统空间也可在用户空间

运行时系统中的所有函数都驻留在**用户空间**



中间系统：运行时系统，用户支持线程

线程的实现：用户级线程，核心级线程，混合线程

# 中断和处理机调度

## 导图：







<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240319162713132.png" alt="image-20240319162713132" style="zoom:80%;" />
中断向量：中断服务程序的入口地址（中断服务程序的PSW（程序状态字）及PC（程序计数器：下一条指令的地址）），在内存中

**中断装置工作过程/中断响应**

  (1)识别中断源。将中断码存入当前的psw中

  引起中断的事件称为中断源。

  当有多个中断源同时存在时，中断装置可选择优先级最高的中断源并响应之。

如：I/O操作的完成，用户键盘的输入等事件

  (2)保存中断现场。将运行进程的PSW及PC （cpu的两个寄存器中）的内容压入系统栈(内存中)。可看出保存PSW和PC是中断装置硬件干的。

  (3)转入中断处理程序。将与中断事件对应的中断向量从内存指定单元取出送入PSW及PC中, 如此便转入对应的中断处理程序。

PSW不运行时在内存中，被压入系统栈，运行时才在PSW寄存器中



上面步骤的细节：**中断响应过程：**  (1)识别中断源，中断装置(硬件)发现中断事件（源），置当前PSW的中断码，即将中断事件存入程序状态字寄存器中当前PSW的中断码位置上。(2)保存中断现场，当前PSW存放到系统栈成为旧的PSW。  (3)转入中断处理程序，然后根据当前PSW的中断码，去中断向量找到新的PSW，新PSW成为当前PSW，把它送入对应的程序状态寄存器，转相应中断处理程序进行处理。实质上就是三个psw的转换。

psw、pc要用一条指令恢复原因：（1）先恢复PSW再恢复PC，再恢复PSW后已经转到目态，操作系统恢复PC的使命无法完成；（2）先恢复PC再恢复PSW，PC改变后转到操作系统另外区域（因为PSW仍为系统状态），PSW无法恢复。（有旧的psw和上升进程下降进程？？？）

**中断处理程序：进入中断处理程序后一般需进一步保存现场**

​    **关中断**（屏蔽所有中断）

​    进一步保存现场(地址寄存器、通用寄存器等)

​    **开中断**

​    中断处理

​    恢复现场

​    中断返回

两次压入系统栈：
**中断响应时**,中断装置将被中断进程的中断向量压入系统栈。？？

**中断响应后**,中断处理程序将被中断进程的其它断点信息,如寄存器内容等压入系统栈。

中断响应通常在中央处理器执行完一条指令后（考）

**123456分别是什么？**

<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240319172951677.png" alt="image-20240319172951677" style="zoom:67%;" />

中断嵌套：旧的PSW有可能也是中断向量

<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240319174228757.png" alt="image-20240319174228757" style="zoom:50%;" />

最后一步转CPU分派：被切入的进程（旧进程）的信息从系统栈到自己对应的进程控制块，切入的进程的信息（PSW和PC）从自己的进程控制块放到cpu运行

<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240319175045066.png" alt="image-20240319175045066" style="zoom:50%;" />



处理机调度：

不支持线程的OS将CPU分配给进程；支持线程的OS，若线程是系统级的，OS将CPU分配给线程，若线程是用户级的，OS将CPU分配给进程。

  处理机资源管理的三个问题

  (1)按什么原则分配处理机 --确定**调度算法**

  (2)何时分配处理机 --确定**调度时机**

  (3)如何分配处理机 --给出**调度过程**



对处理机的一次连续使用称为CPU阵发期。
处理机处理很多进程， 处于CPU阵发期的进程所需要的处理时间称为阵发时间

**FCFS算法**

| Process | Burst time |
| ------- | ---------- |
| P1      | 27         |
| P2      | 3          |
| P3      | 5          |

若进程到达次序为*P*1, *P*2, *P*3，平均等待时间=(0+27+30)/3=19 (ms)

若进程到达次序为P2, P3, P1，平均等待时间 = (0+3+8) / 3 = 3.67 (ms)

FCFS算法的优点：具有公平性，不会出现饿死情况。

FCFS算法的缺点：短进程(线程)等待时间长，从而导致平均等待时间较长

**短作业优先算法**(SJF)

| **Process** | **Burst time** |
| ----------- | -------------- |
| **P1**      | **12**         |
| **P2**      | **5**          |
| **P3**      | **7**          |
| **P4**      | **3**          |

平均等待时间为: (0+3+8+15)/4=6.5(ms)

SJF算法的优点：所有任务同时到达时，其平均周转(等待)时间最短，从而最大限度地降低了平均等待时间。

SJF算法的缺点：具有不公平性。一个较长的就绪任务可能由于短任务的不停到达而长期得不到运行机会，甚至被饿死。  

**最高响应比优先算法**(HRN)

![image-20240320090154043](C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240320090154043.png)

对于同时到达的任务，处理时间短的将被优先调度，处理时间较长的作业将随其等待时间的增加而动态提升其响应比，因而不会出现饿死现象。

**最高优先数算法**(HPF)

**循环轮转算法**(RR)

**分类排队算法**(MLQ)

**反馈排队算法**(FB）

**处理机调度**

**何时可能调用到处理机调度程序呢**?

**中断**，由目态到管态（因为中断是目态到管态的唯一途径，系统才能运行，操作系统才有能系统的控制权，有显式调用的能力，发生**进程切换**，肯定会调度处理机程序



**一定能引起进程切换的中断原因**：

 进程运行终止、进程等待资源、进程等待I/O传输完成等,即当前运行进程一定不能接着执行了

 **可能引起进程切换的中断原因**：

 时钟中断、设备I/O中断信号、系统调用等



处理机调度过程有三个主要步骤（**在关中断下完成**）:

1.保存下降进程现场（系统栈-》PCB）
2.选择将要运行的进程（用调度算法在就绪队列中选择进程） 
3.恢复上升进程现场（PCB-》寄存器）

先恢复通用寄存器等内容,再恢复中断向量,而且中断向量中的PSW与PC的内容必须由一条指令同时恢复

**调度级别与多级调度**



<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240326174104525.png" alt="image-20240326174104525" style="zoom:80%;" />

高级调度：作业调度
发生位置：外存后备队列=》内存

**作业状态之间的转换关系如图所示**：<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240326175016176.png" alt="image-20240326175016176" style="zoom:80%;" />





<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240402175705706.png" alt="image-20240402175705706" style="zoom:67%;" />







对于周期性实时任务，令Ci为任务Pi的处理时问，Ti为任务Pi的发生周期，则任务P1.....Pn 可调度的必要条件为:

<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240327081918328.png" alt="image-20240327081918328" style="zoom:50%;" />

<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240327082017040.png" alt="image-20240327082017040" style="zoom:50%;" />



<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240327081936620.png" alt="image-20240327081936620" style="zoom:50%;" />



**最早截止期优先调度算法**：优先选择完成截止期最早的实时任务

抢占式

例子：

<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240327083908957.png" alt="image-20240327083908957" style="zoom:50%;" />

<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240327083952165.png" alt="image-20240327083952165" style="zoom:50%;" />

非抢占式：<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240327090437571.png" alt="image-20240327090437571" style="zoom:67%;" />

速率单调调度：优先调度发生周期最短(频度最高)的实时任务。（非抢占式）

<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240327085050312.png" alt="image-20240327085050312" style="zoom:50%;" />

最低松弛度优先即LLF(Least Laxity First)算法 （抢占式）

​    该算法是根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高， 以使之优先执行。

<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240327090801940.png" alt="image-20240327090801940" style="zoom:67%;" />

处理时间=该程序还要多少时间处理完成
松弛度可以理解为最晚发生时间

只有当松弛度为0时发生抢占，可抢占调度

自己推：

<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240327092725221.png" alt="image-20240327092725221" style="zoom:67%;" />

第四章

并发程序的特性：（1）交叉性（2）非封闭性（3）不可再现性（4）间断性

若两个程序p1，p2满足如下条件，则能够保持可再现性，因而可以并发执行：R(p1)∩W(p2)∪R(p2)∩W(p1)∪W(p1)∩W(p2)=Φ

考：

例如，有如下四条语句：

  S1: a:=x+y

  S2: b:=z+1

  S3: c:=a-b

  S4: w:=c+1

解：

R(S1)={x,y}，R(S2)={z}，R(S3)={a,b}，R(S4)={c}
W(S1)={a}，W(S2)={b}，W(S3)={c}，W(S4)={w}

可见，R(S1)∩W(S2)∪R(S2)∩W(S1)∪W(S1)∩W(S2)=Φ，因而S1和S2可以并发执行；而S1 和S3不能并发执行，因为W(S1)∩R(S3)={a}；S2和S3也不能并发执行，因为W(S2) ∩R(S3)={b}；同样，S3和S4不能并发执行，因为W(S3)∩R(S4)={c}。

**与时间有关的错误（进程间间接制约）**

发生与时间有关错误的原因：(1) 进程执行交叉(interleave)。    (2) 涉及公共变量(x)（缺少封闭性）。
与时间有关错误的发生根本原因：若两个进程同时对变量x进行操作就是并发进程对共享资源产生竞争

进程互斥（间接相互关系）可能发生在相关进程之间,也可能发生在无关进程之间

进程互斥的实现五大原则

![image-20240409173033762](C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240409173033762.png)

忙等的状态：运行态或者就绪态（考）

**软件实现互斥算法**

**Dekker互斥算法**

Flag表示进程是想进入，在申请临界区：

当 flag[0] 或 flag[1] 为 ture 时，表示 P0 或 P1 在申请（有意愿）临界区；
当 flag[0] 或 flag[1] 为 false 时，表示 P0 或 P1 不申请（没意愿）临界区。

turn表示当前轮流次序（或表示是否可以进入），当0为轮到P0占有临界区，1为轮到P1占有临界区。

<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240409175957461.png" alt="image-20240409175957461" style="zoom: 50%;" />

<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240410082535646.png" alt="image-20240410082535646" style="zoom:50%;" />

缺点：执行的进程死掉了，会导致其他程序一直等待，无法使用，没有进展性

**面包店算法**

 (1)面包店按**由小到大**的次序发放号码,且两个或两个以上的顾客有可能得到相同号码(要使顾客的号码不同，需互斥机制)。

 (2)若多个顾客抓到相同号码,则按顾客名字的字典次序排序(假定顾客没有重名)。

两个数据结构：

choosing[*n*]用来表示第i个进程是否正在抓号，其初值均为0。若进程*i*正在抓号，则choosing[*i*]赋为1，否则choosing[*i*]为0。
number[*n*]用来记录进程抓到的号码，其初值均为0。若number[*i*]为0,则进程Pi没有抓号；若number[*i*]不为0,则其正整数值为进程Pi抓到的号码。

```
p(i):
do{  choosing[i]=1;    /*进程Pi 开始选号码*/
        number[i]=max(number[0],number[1],…,number[n-1])+1; /*进程Pi号码为当前最大号码值加1*/
          choosing[i] = 0; /*进程Pi 选号结束*/
        /*以下是判断竞争进程谁先执行临界区代码？*/
        for (j =0; j<n-1; j++) {
             while (choosing[j])  skip; /*如果进程Pj请求进入临界区但没选好号码，则Pi在此循环等待，等待Pj进程选好号码*/
             while ((number[j]<>0) && (number[j], j)<(number[i], i)) skip;  /*Pi和Pj怎样竞争谁先执行临界区？此处是当条件都满足时，Pi循环等待，Pj进入临界区执行*/
        };
        临界区
        number[i] = 0; /*Pi退处它的临界区时置号码为0，从而允许其他的进程进入临界区*/
        其余部分
    } while(1);

```

优点：进展性，最小的号码总能执行

**硬件实现互斥算法**

**基于TS指令的互斥算法**

```
            int TS(int &target) {
                    int temp;
                    temp:= *target ;
                    *target = 1; 
                    return(temp);
               }
p(i):
            do{  while ( TS(lock) ) skip;
                     临界区   
                     lock = 0;
                     其余部分
             }while(1);
```

硬件提供“交换”(swap)指令

  交换指令**将两个内存单元中的内容相互交换**。交换指令也是原子的。

 **交换指令的定义**如下:

   void swap(int &a, &b) {

​       int temp;

​       temp = *a; *a = *b; *b=temp;

   }

 交换指令在执行时也是不可分割的,即要求**在一个指令周期**内执行完。 （考）

**基于swap指令的互斥算法**

```
 p(i):
 				   do{  key = 1;
                   do{  swap(&lock, &key);
                   }while (key = = 1)
                   临界区
                   lock = 0;
                   其余部分
           		   		}while(1); 

```

上述两个互斥算法均不满足有限等待原则。
正在等待进入临界区的进程在进入临界区之前，原进入临界区的进程继续要求进入临界区，则会造成不满足有限等待原则。

改进，满足有限等待原则：引入变量j，上次拿过的进程就不许再拿

```
p(i):
	do{  waiting[i] = 1;
                key = 1;
                while (waiting[i] && key)
                      key = TS(&lock);   //忙式等待
                waiting[i] = 0;
                临界区
                j = (i+1) % n;    //mod，为了表明是哪个进程，即下一个进程j不是当前进程i
                while ((j != i)&&( ! waiting[j])) %若j不是i，且j并没有等待进入临界区，则继续找一个j不是i，并且正在等待进入临界区的j，去唤醒它，让它进入临界区,此注释解释下面三条语句
                        j = (j+1)% n;   //此语句就是继续找j
                if (j == i)  lock = 0; %若是刚用完临界区的进程，则lock=0
                else   waiting[j] = 0; %若j不是刚用完临界区的进程i，则让j从忙等中退出。即主动唤醒正在忙等的进程。
                其余部分      
        }while(1); 
```



进程同步

进程同步是进程之间的**直接相互作用**，是合作进程之间**有意识**的行为, 这种相互作用**只发生在相关进程之间**









# 1.了解

**操作系统的宏观比喻**



注:磁盘属于外设

**操作系统的启动**一开机启动，有电了，首先时钟震荡器发生时钟信号，使cpu工作，cpu到内存找东西运作，内存一开始为空的，就去磁盘里搬运东西来内存，磁盘首先就是操作系统，主板的boot将c盘的操作系统复制到内存里运行，操作系统为内核态，掌握了最高权限，可以调用软硬件资源的权利。

运行qq（点qq图表一瞬间）：内存里无qq，就到硬盘找，硬盘的d盘有qq，就一行一行二进制代码复制到内存中，再cpu运行

<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240127104718083.png" alt="image-20240127104718083" style="zoom:50%;" />

操作系统功能：
1.管理硬件
2.为上层提供接口

**操作系统运行机制**

人运行机制有三种模式：一为外界环境影响人，二是人内部身体运作免疫机制，三是人的大脑主动采取有利的措施来获取更好的环境生存

公司同样，操作系统也如此：中断（外界如U盘、鼠标等主板外面的东西插入计算机），异常（内部有错误如1除于0），系统调用（主动）



应用软件 访问 操作系统：

应用软件->标准C函数库[API]（为每个系统调用构造一个同名的封装函数）->系统调用->操作系统（二重封装）

**API与系统调用的差别：**https://blog.csdn.net/LinuxZhouYing/article/details/7198118

答：区别：api是函数的定义，规定了这个函数的功能，跟内核无直接关系。而系统调用是通过中断向内核发请求，实现内核提供的某些服务。

  联系：一个api可能会需要一个或多个系统调用来完成特定功能。通俗点说就是如果这个api需要跟内核打交道就需要系统调用，否则不需要。

程序员调用的是API（API函数），然后通过与系统调用共同完成函数的功能。
因此，API是一个提供给应用程序的接口，一组函数，是与程序员进行直接交互的。

系统调用则不与程序员进行交互的，它根据API函数，通过一个软中断机制向内核提交请求，以获取内核服务的接口。

   并不是所有的API函数都一一对应一个系统调用，有时，一个API函数会需要几个系统调用来共同完成函数的功能，甚至还有一些API函数不需要调用相应的系统调用（因此它所完成的不是内核提供的服务）

操作系统与外界（键盘、鼠标)交互：首先按下q键，产生向上脉冲，引脚感知中断信号，知道键盘做了一个操作，之后需要通过八位二进制数来传给操作系统，才能知道是q键

<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240128180352640.png" alt="image-20240128180352640" style="zoom:57%;" />

·用户角度上,操作系统是一个控制软件
·管理应用程序
·为应用程序提供服务
·杀死应用程序
·资源管理，分配资源

kernel：

文件操作系统
内存管理系统
设备驱动系统
调度程序、分派程序

抽象（将硬件虚拟化）

应用程序的下层，硬件的上层，给用户和应用程序提供一个接口

并发：一段时间多个程序运行

并行：一个时间点多个程序运行

Kernel特征：（1）并发 （2）共享 （3）虚拟 （4）异步[2021考研操作系统(启蒙+套路解题，不一样的上分神器)_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1LW411q7Kk?p=8&spm_id_from=pageDriver&vd_source=1f4583ef56826b10e90ed107f460bd8b)



异步原因：关于运行机制：跑步的例子，当你赛跑时，主动策略先快后慢（系统调用），有石子崴脚（中断），肚子痛（异常）

异步在程序运行图解：进程走走停停，具有随机性两个程序A和B都有变量x，若一个先运行x=？，首先检查是否有旗子（锁），若无则要插旗子（上锁)，继续往下运行，若有则暂停等待，直到用完为止拔掉旗子（上完厕所开门)



多道批处理系统，分时系统，实时系统分析https://blog.csdn.net/qq_21989927/article/details/109801283

多核与多处理器的区别http://www.zhangjiee.com/wiki/os/difference-between-multicore-and-multiprocessor.html

# 2.进程管理

## 2.1思维导图

![image-20240128212202331](C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240128212202331.png)

## 2.2 进程的发展史

![image-20220713233703097](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220713233703097.png)

进程与线程的区别：https://cloud.tencent.com/developer/article/1688297

多道程序程序：将多个程序从磁盘读入到内存中，提高了cpu的利用率，让某个程序在IO交互时，cpu运行其他的程序

![image-20220713234647299](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220713234647299.png)

当qq请求IO子系统去访问外设数据时，自己主动失去对cpu的控制，cpu到下一个程序手中，而IO时间有快有慢，可能队伍中的第一个人还是在IO中，他会一开始获得cpu，却因IO阻塞，又主动放弃cpu，就让第二个人（无IO）就绪，调用cpu。（第一个人浪费了一点时间）<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240128215621179.png" alt="image-20240128215621179" style="zoom:46%;" />

分出两种队伍：阻塞队列，就绪队列

当有人放弃cpu时，就绪队伍第一个人获得cpu，放弃的cpu若是IO阻塞，则进入阻塞队列中，若是时间到了被动放弃（分时系统），则进入就绪队列

PCB（档案袋)：记录工具      每个进程都有一个PCB



进程=程序+状态周期搭建（PCB）

当一个软件只靠一个进程时，会造成卡顿。因为网络功能需要通过IO子系统去外面访问网卡（外设），会造成主动放弃cpu，导致渲染功能物理引擎计算等其他停滞


如果是把每一个子内容都安排一个进程的话：会导致空间复杂度太大（因为每个进程除去本身，还需要分配一个栈空间，存放当前进程运行的位置（书签），也会使PCB过多（难于查询和修改，导致时间复杂度过大）



**进程到线程**优化每个进程包括许多线程，每个线程完成一个功能



## 2.4进程与程序的区别：

（1）程序是静态的，进程是动态的（程序是代码，而进程是代码加PCB（状态加动态信息））
（2）进程是程序的一次执行（从新建到结束）

（3）进程与程序不是一一对应



## 2.5进程的特性

（1）并发性（参考OS特性）
（2）异步性（参考OS特性）
（3）独立性（不同进程之间互不干扰）
（4）结构性（进程=程序+PCB，程序=数据段+程序段（指令段） 如6+8，6和8为数据段，+为指令段）
（5）动态性（PCB存进程动态信息）

## 2.6进程的结构

<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240128225852075.png" alt="image-20240128225852075" style="zoom:67%;" />PCB是一个进程存在的唯一标识

## 2.7进程间通信

管道、消息队列、共享内存

## 2.8三级调度

调度：高级调度（程序首次由硬盘到内存：频率低，耗时长，必定发生）、中级调度（磁盘和内存交换数据，解决了内存空间不够的问题：频率中，可能发生）、低级调度（在内存中的不同程序分配cpu：频率极高，必定发生）

<img src="C:\Users\13030\AppData\Roaming\Typora\typora-user-images\image-20240129102515413.png" alt="image-20240129102515413" style="zoom: 50%;" />为什么内存空间（4G)很小，游戏占10多个G，可以运行？
原因：游戏10匹配英雄（100M)才会加载到内存里运行，其他的还在磁盘里，下一把使用其他英雄，则中级调度，将马上用的从磁盘换掉不用的空间

## 2.9调度算法及调度过程

调度方式：主动，被迫放弃

**FCFS算法**

算法思想：先排队先服务
调度方式：不可剥夺
调度时机：一个进程结束
特点：利长不利短，利cpu忙不利IO忙，不利于分时、实时系统
典型案例：打印机、银行窗口

**时间片算法**

![image-20220716105743327](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220716105743327.png)

当时间片的时间到了的时候，时钟电路会中断信号，提醒cpu到os里的进程管理模块中的调度器去查看排队队列，队列以PCB（进程存在的唯一标识）排列，下一个进程则会占用cpu运行。

**SJF算法（最短时算法)**

![image-20220716152002595](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220716152002595.png)

**优先级算法**

该优先级为PCB里的进程优先级，分为动态优先级和静态优先级

静态优先级是在创建进程时确定的，在进程的整个运行期间保持不变。

动态优先级　　
动态优先级是指在创建进程之初，先赋予其一个优先级，然后其值随进程的推进或等待时间的增加而改变，以便获得更好的调度性能。

分为抢占式和非抢占式，抢占式为一个低优先级正在运行中，一个更高优先级进入队列，直接暂停换成更高优先级的进程工作，非抢占式为程序结束时，根据优先级队伍，将cpu给最高优先级的进程，IO阻塞时，将cpu给到队伍中优先级第二高的进程，然后，等到IO结束时，该最高优先级会等到第二高的进程执行完后执行，不会直接抢占。![image-20220716154140538](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220716154140538.png)

**高响应比算法**![image-20220716170245981](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220716170245981.png)

![image-20220716165824866](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220716165824866.png)

**多级反馈队列调度算法**

![image-20220717000025045](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220717000025045.png)

5、优先执行高优先级队列中的队首进程，若高优先级队列中没有就绪进程，则执行下一级优先级
队列中的队首进程。 
6、正在执行低优先级队列中的队首进程时，有新的进程到达高优先级队列，则立即中断低优先级
进程，并切换到高优先级进程执行。 

## 2.10甘特图

![image-20220717002244399](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220717002244399.png)

## 2.11调度准则

五大指标：

1.响应时间
2.系统吞吐量=程序从硬盘到内存再到执行完成的量
3.等待时间
4.CPU利用率
5.周转时间=等待时间+运行时间+IO阻塞时间

![image-20220717122449633](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220717122449633.png)[响应时间](https://baike.baidu.com/item/响应时间?fromModule=lemma_inlink)，是从用户通过键盘提交一个请求开始，直至系统首次产生响应为止的时间，或者说，直到屏幕上显示出结果为止的一段时间间隔

## 2.12临界资源与临界区

临界资源：一次只能被一个进程所使用的资源（分为硬件：打印机、网卡、键盘，软件：共享变量----插旗子（交通灯）![image-20220717172602619](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220717172602619.png)

## 2.13同步与互斥

![image-20220718144225569](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220718144225569.png)

同步![image-20220718112024653](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220718112024653.png)

同步：运行次序的制约关系
互斥：共享资源的制约关系

理解：打篮球时，队友传球是同步（合作），和对手争一个球是互斥。

硬件实现![image-20220718114245531](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220718114245531.png)

**软件实现**![image-20220905085833867](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220905085833867.png)

单标志法

双标志先检查法

双标志后检查法

peterson算法

[进程同步 进程互斥 软件和硬件实现方式 信号量机制 信号量机制实现进程同步，进程互斥，前驱关系 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/56159336)

## 2.14信号量

### 2.14.1信号量的由来

将互斥（软件：peterson算法，硬件：中断屏蔽和硬件指令）的实现方法抽象化成进入区，临界区，退出区，再把进入区抽象成p操作，退出区抽象成v操作，来共同控制信号量

信号量模仿交通灯

信号量(Semaphore)，有时被称为信号灯，是在多线程环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被[并发](https://baike.baidu.com/item/并发)调用。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量。

![image-20220719085149245](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220719085149245.png)![image-20220905100304464](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220905100304464.png)

### 2.14.2pv操作

p:等待，v：释放

![image-20220719102944423](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220719102944423.png)

火锅店老板指操作系统，左边吃饭指cpu运行进程，排队指阻塞队伍，value指还可以多少进程执行cpu

![image-20220719103953605](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220719103953605.png)

操作系统提供两个API接口，P和V接口，进程通过pv操作就让操作系统去执行函数里面具体的内容![image-20220719103957068](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220719103957068.png)![image-20220719103958869](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220719103958869.png)

### 2.14.3同步实现

![image-20220719110449093](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220719110449093.png)

### 2.14.4互斥实现

![image-20220719111422382](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220719111422382.png)

![image-20220719113934540](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220719113934540.png)![image-20220720085331859](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220720085331859.png)

![image-20220720085325031](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220720085325031.png)

### 2.14.5生产者与消费者/读者写者

[2021考研操作系统(启蒙+套路解题，不一样的上分神器)_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1LW411q7Kk?p=50&vd_source=1f4583ef56826b10e90ed107f460bd8b)

[2021考研操作系统(启蒙+套路解题，不一样的上分神器)_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1LW411q7Kk?p=55&spm_id_from=pageDriver&vd_source=1f4583ef56826b10e90ed107f460bd8b)

## 2.15死锁

### ![image-20220801093139259](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220801093139259.png)2.15.1死锁三胞胎![image-20220801093722734](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220801093722734.png)

![image-20220801093141956](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220801093141956.png)

### 2.15.2死锁的原因与条件

分为两种：人工层面（对信号量的赋值不当）和 操作系统层面（对有限不可剥夺的资源的竞争）

竞争两种理解：多进程对有限不可剥夺的资源的竞争，进程申请资源的推进顺序不合理（不是两种进程各占一半，而应一个进程使用完整个资源后给另外一个）

死锁的每一次发生，必然都具备这四个以下条件：

1：互斥条件：指进程对所分配到的资源进行排他性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其他进程请求资源，则只能等待，直至占有资源的进程用毕释放。简而言之，即资源不能共享，只能由一个资源使用。(多个进程争夺一个资源)

2：请求与保持条件：指进程已经至少保持一个资源，但又提出来对新的资源的请求，而该资源已经被其它进程占用，此时请求进程阻塞，但又对自己已获得的资源保持不放。（不能谦让）

3：非剥夺条件：指进程已经获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己来释放。（不能强占)

4：循环等待条件：指发生进程死锁时，必然存在一个由进程组成的资源环形链。系统中的若干进程组成环路，该环路中的每个进程都在等待相邻的进程正占用的资源。
![image-20220801104858026](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220801104858026.png)

### 2.15.3避免死锁

什么是银行家算法?
　　银行家算法（Banker’s Algorithm）是一个避免死锁（Deadlock）的著名算法，是由艾兹格·迪杰斯特拉在1965年为T.H.E系统设计的一种避免死锁产生的算法。它以银行借贷系统的分配策略为基础，判断并保证系统的安全运行。
　　在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程。
		银行家算法是一种最有代表性的避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。为实现银行家算法，系统必须设置若干数据结构。

### 2.15.4 死锁的检测与解除

检测与避免的区别：检测可以是任何一个周期来检测是否死锁，而避免是要寻找一个安全周期避免死锁

![image-20220801151535217](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220801151535217.png)

![image-20220801151545359](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220801151545359.png)

![image-20220801160247974](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220801160247974.png)

该图为死锁，根据上面的方法

## 2.16 cpu怎么访问内存

![image-20220907090439011](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220907090439011.png)

数字电路的译码器原理：共有2的32次方行，每一行表示地址，每一行地址存放8位数据

左边有3位，右边译码出8位二进制数

左边有32位，**右边译码出2的32位=4GB内存空间**=4*2的10次方 * 2的10次方 * 2的10次方

具体cpu执行过程：cpu给出一个含32位的二级制地址，然后到内存中响应的行里，将这一行8位数据通过数据总线传给cpu的寄存器使用![image-20220907094935655](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220907094935655.png)

易混淆的概念：![image-20220907135548992](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220907135548992.png)

其中可访问内存大小由物理地址总线数（32位还是64位cpu决定）、os位数（软件自定义需要多少内存）、内存卡（实际情况）

分别由硬件、软件、实际考虑

此外，cpu位数大于等于os位数（因为软件基于硬件之上）

# 3.内存管理

## 3.1思维导图

![image-20220907153853010](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220907153853010.png)

## 3.2编译、链接、装入

![image-20220907160009031](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220907160009031.png)

错位现象：当一段程序读入到内存中，由于程序的逻辑地址（相对地址）与内存条的物理地址（绝对地址）有错位，如程序中的6，8，10会跑到物理地址的6，8，10行，导致错误![image-20220907162452821](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220907162452821.png)

### 3.2.1绝对装入

绝对装入：物理地址与程序的逻辑地址对应

![image-20220907163757855](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220907163757855.png)

### 3.2.2静态重定位装入

静态重定位装入：逻辑地址加上要定位的物理地址，**但一旦装入内存卡就不能随意移动，要修改只能从磁盘重新装入**

### 3.2.3动态重定位装入

动态重定位装入：加法弥补作用（通过PCB里的起始地址，重定位寄存器改为1000，然后程序里的地址加上1000），**只需要修改PCB里的入口地址，就可以动态移动程序的地址（将内存的程序任意移动位置）**

![image-20220908104244197](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220908104244197.png)

## 3.3进程保护

![image-20220908105557123](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220908105557123.png)

两种实现方法：（1）上下限寄存器，cpu只能在这区间执行，超过上下限无法访问
						 （2）基址寄存器（重定位寄存器决定起始位置）、限长寄存器（决定区间长度）

两种实现方法都需要PCB的更新，提供数据

## 3.4内存分配（硬盘到内存）

## 3.4.1连续存储分配

**单一连续分配**

碎片：内存还有剩余空间

内部碎片：分配内存大于程序，导致内部的内存空间浪费

![image-20220908111711103](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220908111711103.png)

**固定分区**

固定分区分为大小相等分区和大小不等分区（更加符合大的程序存入大的内存空间，小的存入小的）

![image-20220908184854763](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220908184854763.png)![image-20220908184856879](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220908184856879.png)

程序通过分区说明表来观看哪一个分区是空的

**动态分区**

![image-20220908191710222](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220908191710222.png)

动态分区算法：![image-20220908192558770](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220908192558770.png)

首次适应：从头开始扫描，第一个可装入的分区装入
最佳适应：装入最接近程序大小的内存空间（如程序为5MB，则装入6MB的内存空间里）会产生许多的外部碎片
最坏适应：装入最大的内存空间（如程序为5MB，则装入10MB的内存空间里）
邻近适应：从上一次位置开始扫描，第一个可装入的分区装入

外部碎片（不属于程序的内存空间）多了采用紧凑技术（动态重定位）---->将程序的位置移动，将碎片放在一起。

## 3.4.2不连续存储分配	

### **基本分页技术**![image-20220908231446467](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220908231446467.png)

由于连续分配会带来碎片，积少成多，造成大量内存空间浪费，所以将程序切成块，内存也切成相同的块，这样可以充分利用每一块空间

将内存、硬盘、程序分为相等的块（一般为4kb）

块在不同区域的不同名字：
内存-------页框（页帧）
程序-------页面
硬盘-------磁盘块

![image-20220909111715645](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220909111715645.png)

**具体实现：**首先操作系统访问该程序的PCB，PCB提供**内存中**页表的位置，再通过页表可知程序的页面该存入内存里的哪个页框

细节：页表项为一行，左边为页号，右边为物理块号![image-20220909114348941](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220909114348941.png)

#### **逻辑地址与物理地址关于页表的关系**

![image-20220909221909563](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220909221909563.png)

前提须知：
（1）32位操作系统允许最大的程序为2的32次方-------最大页号为2的32次方÷2的12次方=2的20次方
 64位操作系统允许最大的程序为2的64次方---------最大页号为2的64次方÷2的12次方=2的52次方

4kb=2的12次方=4096 2的12次方为一组 怎么通过逻辑地址得出第几组？

（人）十进制：n/2的12次方=第几组 n%2的12次方=该组的第几行
（机器）二进制：后12位的值为该组第几行，剩余前面的位为第几组

所以可以通过逻辑地址确定页面的位置在第几组，再通过页表得出物理地址在第几组，第几行通过上面的计算（页面在第几行=物理块号在第几行

#### **基本地址变换机构**

页表寄存器（在cpu里，只有一个）包括页表起始位置和页表长度，不同的程序通过PCB来更新页表寄存器里的信息，若页号大于页表长度，意味着已经超出该程序的范围，中断。

![image-20220909231023493](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220909231023493.png)

**改进：快表（相当于浏览记录，存在cpu内，先访问快表，若没有，则再去内存中找）** 作用：减少访问内存次数

![image-20220910112314695](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220910112314695.png)

访问内存次数![image-20220910113001344](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220910113001344.png)

快表：直接找到物理地址，然后再访问内存中相应地址（1）
页表：首先要通过访问内存中的页表（1），找到物理地址，然后再访问内存中相应地址（1）

#### 二级页表

原因：页表太过于大，且浪费

计算页表大小：32位操作系统，2的32次方÷2的12次方=2的20次方个页表项，每个页号要装20位的数字=2.5B，按照4B算，4B*2的20次方=4mb，页表是存在内存里的，会十分占空间。所以将页表也分成一块一块

![image-20220910152741824](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220910152741824.png)

具体实现：![image-20220910172647367](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220910172647367.png)**多级页表**![image-20220910171913046](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220910171913046.png)![image-20220910172316864](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220910172316864.png)

### 请求分页技术(虚拟内存技术)

![image-20220911101404697](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220911101404697.png)

优化：因为有许多循环，重复的代码，和分散的模块一次性使用完就没有用了，没有必要占用内存空间，所以采用请求分页技术，分批装入，分批调出。

**驻留集、工作集**

驻留集：物理框装的页面的集合

程序分为主程序（较重要，出入不频繁，缺页率较大，占用物理块久）和子程序（出入频繁，缺页率小，占用物理快小）

![image-20220911105734377](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220911105734377.png)

![image-20220911120152418](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220911120152418.png)

**请求分页页表**

**包含页号**，**物理块号**，**状态位/有效位**（是否存入到内存中，若为0，则没存入，缺页中断，并产生IO阻塞，中断处理程序再通过调度算法存入内存中），**外存地址**，**询问字段**（执行次数，若询问字段大，则代表是长工，若询问字段小，则代表是短工，一般替换将短工替换掉）**使用位**（若数据再内存中有更新的话，则为1，需要覆盖到硬盘上，无更新则为0）

![](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220911161409099.png)

### 调度算法

**OPT算法**

OPT算法：一种不可能实现的算法，但是是最理想的算法：替换将来最久时间不用的页面（无法预知未来，只能当作一个标准去评判其他的）

缺页中断时机：当物理块里没有程序时，当有效位为0时执行该页面
页面置换时机：当有效位为0时执行该页面

缺页中断次数 = 物理块个数 + 页面置换次数

![image-20220911171723403](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220911171723403.png)

**LRU算法**

LRU算法：过去最久未使用的页面

![image-20220913210756035](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220913210756035.png)



**FIFO算法**

FIFO算法：上一次最早出现在内存的替换

![image-20220913210047404](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220913210047404.png)

**CLOCK算法**

![image-20220913212336525](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220913212336525.png)

![image-20220913212431967](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220913212431967.png)

**规则：首次装入置1，再次访问置1。扫描时将1变为0，将0的代替**

### 扩充内存的方法

**覆盖技术**

![image-20220908200435630](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220908200435630.png)

将程序分为架构，主程序A、子程序B、子程序F为1组先放入内存中的固定区、覆盖区1、覆盖区2，等执行完，再更改覆盖区的程序，改为子程序C、D、E

**交换技术**

![image-20220908202250763](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220908202250763.png)

内存已经满了，磁盘里的程序通过交换区交换内存中阻塞程序

## 虚拟内存补充

![image-20220914095926914](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220914095926914.png)

抖动现象：工作集（驻留集）分配太小（如分配一块），会不断置换程序。

**快表结构分类**

1.直接映射
2.全相联映射（之前学过的，与页表一样）
3.组相联映射（把多项分为一组查询）
组相联映射 分为TLB标记和组索引

TLB标记需在高位（因为快表需唯一
000 100
001 101
010 110 
011 111 
3位二进制，8条目2路组相联，分为4组，后两位为组索引（00-01-10-11-00重复），第一位为TLB标记（在组索引确定的情况下，唯一，从0到1）

![image-20220914110519716](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220914110519716.png)

![image-20220914110911940](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220914110911940.png)

## 3.4.3基本分段存储分配

基本分页：提高内存的利用率（站在电脑的角度）
基本分段：共享（站在人的角度）

基本分段：将a程序，b程序，c程序，一段存入，不同程序之间分散

![image-20220914154641265](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220914154641265.png)

好处：当程序多开时，有的程序（如网络）可以复用，内存中不用多出a2，b2

![image-20220914154901841](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220914154901841.png)

段表：![image-20220914195026246](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220914195026246.png)

**逻辑地址求物理地址**

![image-20220914200400719](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220914200400719.png)逻辑地址（段号+段内偏移量（最大的段大小))

物理地址 = 内存起始地址 + 偏移量

# 4.文件



文件：将数据打包在一起，易于区分

![image-20220915102600778](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220915102600778.png)

FCB：文件的档案袋 存的是文件类型

文件组在一起形成了目录

## 4.1文件管理逻辑图

![image-20220915111545674](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220915111545674.png)

文件系统层次结构图

![image-20220924093230214](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220924093230214.png)

分层设计的优点：上下层互不影响，耦合性低，便于版本更新，修改代码，移植

## 4.2文件的逻辑结构（数据如何组成文件）

文件在硬盘里是分散存储的（磁盘块4kb），但在拷贝到内存中是有序的（因为只有有序的，文件才能执行出原本的东西）

![image-20220915201923192](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220915201923192.png)

**逻辑结构**

无结构文件

![image-20220915204932323](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220915204932323.png)

有结构文件![image-20220915205639025](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220915205639025.png)

**顺序文件**  

结构（针对数据项的排序）分为串结构和顺序结构

定长变长针对于数据项的分布![image-20220917093737227](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220917093737227.png)

**索引文件**

因为变长数据项很难访问（顺序访问一个一个找）所以开辟一块空间给索引表，存每个变长数据项的位置

![image-20220917095358801](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220917095358801.png)

**索引顺序文件**

与索引文件类似，只是不把每个数据项的位置存入索引表，而是分组，把组的第一个位置存入索引表，组内无序，需按照顺序读取，组间有序![image-20220917100527801](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220917100527801.png)

## 4.3目录文件的逻辑结构（PCB如何组织起来的）

### 4.3.1文件控制块FCB

![image-20220917110808197](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220917110808197.png)

目录文件存的是文件的FCB（文件的档案袋）

### 4.3.2索引节点inode

**优化**：将磁盘信息集中存放到inode，与文件名分离，减少FCB的大小

![image-20220917153958587](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220917153958587.png)

### 4.3.3目录结构

**单级目录结构**

特点：没有文件夹，打开磁盘全是文件（多个普通文件和一个目录文件）![image-20220917162411255](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220917162411255.png)

**双级目录结构**

![image-20220917164115141](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220917164115141.png)

优点：多用户隔离，其他人无法观看自己的文件
缺电：没有文件夹，到最底层都是文件；FCB都是连续存储

**多级目录结构**![image-20220917165829679](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220917165829679.png)

### 4.3.4文件共享

**共享方法：**![image-20220917183910200](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220917183910200.png)

文件共享原因：
1.节约空间，若三个用户不共享该文件，则需创建三个一模一样的文件
2.联网需求，服务器需给用户共享文件。

共享方法：

硬链接：在目录文件添加一份要共享的资料的FCB

软链接、硬链接（具体查看linux）

### 4.3.5文件保护

保护方式：1.加密
				  2.加口令
				  3.加权限（rwx）

## 4.4文件的物理结构（文件是如何存入磁盘块的）

![image-20220919180543021](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220919180543021.png)

### 4.4.1文件分配磁盘块的方式

酒店先登记再入住，文件先在目录文件FCB里存入信息，再分配磁盘块，然后qq程序让操作系统将a.txt读入，磁盘块读入内存，再读取

**连续分配**

优点：可直接访问
缺点：碎片多，只适合大小固定

![image-20220919093742930](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220919093742930.png)

**链接存储**

**隐式链接**

类似于链表，将头结点，和尾结点存到FCB中，这样大大利用了磁盘的空间，减少了外部碎片

缺点：只能顺序访问，不能直接访问

![image-20220919095635716](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220919095635716.png)

**显式链接**

将链表单独存放在FAT表中

![image-20220919122529261](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220919122529261.png)

**单级索引存储**

将一个磁盘块专门存放索引表，然后FCB存放索引表的位置。

优点：直接访问
缺点：索引表占据空间（当文件越大，所需磁盘块越多，所需记录的索引表越大，可能需要多个磁盘块存索引表）

![image-20220919171016435](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220919171016435.png)

**多级索引存储（用索引表去存索引表）**

当程序过大时，索引表变得很多，此时，需要另外一个索引表去存前面很多的索引表的编号，此为二级索引

![image-20220919174123033](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220919174123033.png)

**混合索引**

混合索引采用先直接索引，然后单级索引，然后二级，三级····

设一个磁盘块可存4kb，一个磁盘块号为4b

直接索引最大可存4kb
单级索引最大可存1k * 4kb=4MB
二级索引最大可存1k * 1k * 4kb = 4GB 
三级索引最大可存1k * 1k * 1k * 4kb = 4TB

![image-20220919175241816](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220919175241816.png)

### 4.4.2存储空间管理

**空闲表法（针对连续存储）**

![image-20220919181242594](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220919181242594.png)

**空闲链表法**

将空的磁盘块号按照链表形式存储

![image-20220919200401700](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220919200401700.png)

**位示图法**

创立一个二维数组，若存了数据则置1，未存置0

第几个数（b）与 i 和 j 有个等式关系![image-20220919202314430](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220919202314430.png)

**分组链表法**

![image-20220919202932279](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220919202932279.png)

## 4.5目录的物理结构（FCB的存储结构）

物理结构分为：线性表（依次查询），hash表（直接计算，不做要求）

线性表

![image-20220921162851482](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220921162851482.png)![image-20220921162853497](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220921162853497.png)

中间的省略号最多可以存80÷10 = 8个磁盘块

## 4.6文件读取

![image-20220924113647364](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220924113647364.png)

## 4.7磁盘的硬件结构



<img src="C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220924113828720.png" alt="image-20220924113828720" style="zoom:27%;" />

补充：磁头是从外到内读，在一个柱面，一个盘面一个盘面读

### 4.7.1磁盘一次读写时间

![image-20220924122431775](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220924122431775.png)

![image-20220924132751777](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220924132751777.png)

### 4.7.2磁盘调度算法（减小寻找时间）

**FCFS算法：按照顺序存储**
<img src="C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220924151353377.png" alt="image-20220924151353377" style="zoom:67%;" />

**SSTF算法：按照最近的磁道**

![image-20220924152351772](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220924152351772.png)

**SCAN：第一次最近算法+到头折返**

**LOOK算法：第一次最近算法+最远请求折返**

![image-20220924154447840](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220924154447840.png)

**CSCAN算法：选定一个方向一直跑，到边界则重头跑**

**C-LOOK算法：选定一个方向一直跑，到最远请求重头跑**

<img src="C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220924155412453.png" alt="image-20220924155412453" style="zoom: 67%;" />

### 4.7.3减小延迟时间

<img src="C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220924164324850.png" alt="image-20220924164324850" style="zoom: 67%;" />

磁头处理过程：先读（磁信号）---再处理（电信号）--再继续读（磁信号）

扇区特点：头（无用需删除，耗费一点时间）+数据+尾（无用需删除，耗费一点时间）

<img src="C:\Users\Tom\Desktop\微信图片_20220924170501.jpg" alt="微信图片_20220924170501" style="zoom:67%;" />

盘面按照交替存储，因为处理头和尾需要时间，但磁盘还在转动
不同盘面按照错位进行存储，以便执行完第一个盘面可以直接读取第二个盘面

文件管理系统，操作系统重启

# 5.IO系统

## 5.1IO系统逻辑图

<img src="C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220924222148652.png" alt="image-20220924222148652" style="zoom:150%;" />

## 5.2设备分类

![image-20220924223901040](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220924223901040.png)

## 5.3数据传输方式

![image-20220926103529557](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220926103529557.png)

[(9条消息) CPU与外设间数据传输方式_蝴蝶π的博客-CSDN博客_cpu与外设之间的数据传送方式](https://blog.csdn.net/m0_61231111/article/details/125067064)



**程序直接控制方式**（低速）![image-20220926122638538](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220926122638538.png)

键盘输入字母，cpu隔段时间要在输入进程中检测有无新的数据通过数据总线传入，若有则传给目标进程

**中断程序控制**（低速）

![image-20220926154333531](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220926154333531.png)

中断传送方式则是由外设主动向CPU发出请求，中断程序需要控制总线来传给cpu，等候CPU处理，在没有发出请求时，CPU和外设都可以独立进行各自的工作

**DMA控制方式**（快速）

<img src="C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220926161041657.png" alt="image-20220926161041657" style="zoom:180%;" />

第三步和第四步一直循环，直到数据计数寄存器存够了个数为DC的值。

**通道**（在DMA基础上添加一个主管，减少了cpu的配置DMA次数<img src="C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220926170301595.png" alt="image-20220926170301595" style="zoom:250%;" />

## 5.4缓存技术

缓存技术：高速存储器存储低速存储器的副本，来提高cpu对数据访问速度

<img src="C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20220926211323026.png" alt="image-20220926211323026" style="zoom: 67%;" />



Cache是怎样工作的呢？

您一定明白CPU的运算速度比主内存的读写速度要快得多，这就使得CPU在访问内存时要花很长的等待时间，从而造成系统整体性能的下降。为了解决这种速度不匹配的问题，需要在CPU与主内存之间加入比主内存更快的SRAM（Static Ram，静态存储器）。SRAM储存了主内存中的数据(专业术语称为“映象”)，使CPU可以直接通过访问SRAM来读写数据。由于SRAM的速度与CPU的速度相当，因而大大缩短了数据读写的等待时间，系统的整体速度也就得到了提高。既然SRAM那么快，为什么不用来作为主内存呢？这是因为SRAM采用了与CPU相类似的半导体制造工艺，成本极高，只有在那些只关心性能不考虑价格的场合才会这样做。这也就使得Cache粉墨登场了，**它能将CPU用过的数据，以及结果保存起来，让CPU下次处理时先来访问Cache，如果没有可用的数据再去别处找，以此来提高运行速度**。

举例：1.快表是页表的缓存（页表是存储页面和磁盘块的对应关系）
 		   2.内存里的页面是硬盘里的磁盘块的缓存，cache里的内容是内存最近使用页面的缓存

## 5.5缓冲技术

缓冲：将IO里的低速数据提前存入内存里的缓冲区中，缓冲区再移到工作区，cpu再执行（以时间换速度）

网卡（IO设备）若传输到内存数据太慢，cpu先运行一部分数据，然后就卡住一段时间，然后再运行一部分），所以缓冲技术就是先等待几分钟，让视频把后面的数据加载完再播放

优点：
(1)缓和cpu与外设之间速度不匹配的矛盾
(2)解决数据基本数据单元大小不匹配的的问题（外设一次可以传输3分之1个图片，而cpu需要一个完整图片才会去执行）
(3)减小I/O对cpu的中断频率
(4)提高cpu与I/O设备的并行性(并行性指cpu和I/O设备同时运行不同程序)

**单缓冲区**

缓冲区使用原则：非空即满，空->满 满->空

三块时间：输入时间（生产时间）、传送时间（取出时间）、处理时间（消费时间），平均处理时间MAX{生，消}+取

其中，生产时间与取出时间相互制约，取出时间与消费时间相互制约

![image-20221002120117869](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20221002120117869.png)

**双缓冲区**

双缓冲区：有两个缓冲区，平均处理时间MAX{生，取+消}

![image-20221002154837503](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20221002154837503.png)

当 生>取+消时，IO设备可连续输入，但cpu会等待

当 生<取+消时，IO设备不是连续输入，但cpu很忙

**循环缓冲区**

循环链表，有两个指针in和out
若生产>消费+取出，则很快in就占满了空间，然后cpu忙
若生存<消费+取出，则则IO设备连续输入，cpu等待



**缓冲池**

缓冲池：对于所有程序而言，前面的循环缓冲区、双缓冲区、单缓冲区对于单个程序而言

缓冲池按照不同方向分队列：

站在程序的角度：输入队列、输出队列、空闲队列（输入和输出是相对的）

<img src="C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20221003152031797.png" alt="image-20221003152031797" style="zoom: 40%;" />

**Spooling**

**spooling系统的三大组成部分：**

<1>.输入井和输出井

<2>.输入缓冲和输出缓冲

<3>.输入进程SPi和输出进程SPo

SPOOLing 技术实际上是一种外围设备同时联机操作技术,又称为排队转储技术。

它在输入和输出之间增加了“输入井”和“输出井”的排队转储环节。

若有进程要求对它打印输出时，SPOOLing系统并不是将这台打印机直接分配给进程，而是在共享设备（磁盘或磁鼓）上的输出SPOOLing存储区中为其分配一块存储空间，进程的输出数据以文件形式存放于此。各进程的数据输出文件形成了一个输出队列，由输出SPOOLing系统控制这台打印机进程，依次将队列中的输出文件实际打印输出。在SPOOLing 系统中，实际上并没有为任何进程分配，而只是在输入井和输出井中，为进程分配一存储区和建立一张I/O请求表。这样，便把独占设备改造为共享设备。

<img src="C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20221003152145086.png" alt="image-20221003152145086" style="zoom:47%;" />

## 5.6设备的分类

<img src="C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20221003152641747.png" alt="image-20221003152641747" style="zoom:90%;" />

## 5.7IO层次结构

![image-20221003161713746](C:\Users\Tom\AppData\Roaming\Typora\typora-user-images\image-20221003161713746.png)
